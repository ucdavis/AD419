-- =============================================
-- Author:		Ken Taylor
-- Create date: November 26, 2014
-- Description:	Load the PI_Names and PI_Match table for later 
-- use in getting expenses for PIs by accession numbers per orgR.
-- Usage:
/*
	EXEC [dbo].[usp_LoadPI_NamesAndPI_Match] @IsDebug = 0
*/
-- Modifications:
--	20160815 by kjt: Added usage example.
--		Removed chart 3 as expenses are also coming from chart L
--	20170511 by kjt: Added non--241 PI names as well.
--	20170821 by kjt: Added the TitleCode LIKE 33% OR TitleCode IN ('3220', '3210', '3200')
-- =============================================
CREATE PROCEDURE [dbo].[usp_LoadPI_NamesAndPI_Match] 
	@IsDebug bit = 0 -- Set to 1 to print results generated by this procedure only.
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	--DECLARE @IsDebug bit = 0

	DECLARE @Orgs TABLE (OrgR varchar(4),[Org-Dept] varchar(200))
	INSERT INTO @Orgs 
	EXECUTE [dbo].[usp_getReportingOrg]

	DECLARE @PI_Names TABLE (employee_name varchar(200), EID varchar(50),
	LastName varchar(50), FirstNameMI varchar(75), FirstName varchar(50), FirstInitial varchar(1), MiddleInitial varchar(1),
	PI_LFM varchar(100), PI_LF varchar(100), PI_LastNameFirstName varchar(200), OrgR varchar(4))

	DECLARE @Table TABLE (Project varchar(50), Accession varchar(50), PI varchar(200), OrgR varchar(4))

	DECLARE myCursor CURSOR FOR SELECT OrgR FROM @Orgs
	WHERE OrgR NOT IN (
		SELECT OrgR FROM dbo.udf_GetOrgRExclusions()
		)
	ORDER BY 1

	OPEN myCursor
	DECLARE @OrgR varchar(4) = ''
	FETCH NEXT FROM myCursor INTO @OrgR

	WHILE @@FETCH_STATUS <> -1
	BEGIN 
		--DECLARE @PI_Names TABLE (employee_name varchar(200), EID varchar(50),
		--LastName varchar(50), FirstNameMI varchar(75), FirstName varchar(50), FirstInitial varchar(1), MiddleInitial varchar(1)
		--,PI_LFM varchar(100), PI_LF varchar(100), OrgR varchar(4))
		--Gets the PI names and EIDs  for a particular org R

		INSERT INTO @PI_Names (employee_name, EID)
		--select distinct REPLACE(Employee_Name, '.', '') employee_name, EID -- remove periods from initials
		--FROM expenses WHERE FTE_SFN = '241'
		--AND OrgR = @OrgR --AND Chart = '3'
		--group by EID, REPLACE(Employee_Name, '.', '')
		--ORDER by 1
		SELECT DISTINCT REPLACE(Employee_Name, '.', '') employee_name, EID -- remove periods from initials
		FROM Expenses 
		WHERE FTE_SFN = '241' AND
			OrgR = @OrgR --AND Chart = '3'
		GROUP BY EID, REPLACE(Employee_Name, '.', '')

		UNION

		SELECT DISTINCT REPLACE(Employee_Name, '.', '') Employee_Name, EID
		FROM Non241PI_EmployeeNames
		WHERE OrgR = @OrgR

		UNION 
		
		SELECT DISTINCT REPLACE(Employee_Name, '.', '') Employee_Name, EID
		FROM Expenses 
		WHERE FTE_SFN != '241' AND 
		OrgR = @OrgR AND 
		(TitleCd LIKE '33%' OR TitleCd IN ('3220', '3210', '3200')) AND
		FTE_SFN <> '241' AND 
		(Employee_Name IN (
			SELECT DISTINCT PI_Name
            FROM dbo.Expenses
			)
		) AND (Employee_Name IS NOT NULL)
		GROUP BY EID, REPLACE(Employee_Name, '.', '')
		ORDER BY 1

		UPDATE @PI_Names SET OrgR = @OrgR WHERE OrgR IS NULL

		UPDATE @PI_Names
		SET LastName = SUBSTRING(employee_name, 0, CHARINDEX(',', employee_name, 0) ) ,
			FirstNameMI = SUBSTRING(employee_name, CHARINDEX(',', employee_name, 0) + 1, 75 ),
			FirstInitial = SUBSTRING(employee_name, CHARINDEX(',', employee_name, 0) + 1, 1 )

		UPDATE @PI_Names
			SET FirstName = SUBSTRING(FirstNameMI, 0, CHARINDEX(' ', FirstNameMI, 0) )

		UPDATE  @PI_Names
		SET MiddleInitial = SUBSTRING(FirstNameMI, CHARINDEX(' ', FirstNameMI, -1) + 1, 1 )
		WHERE FirstName NOT LIKE ''
		
		UPDATE @PI_NAMES
			SET FirstName = FirstNameMI 
			WHERE MiddleInitial IS NULL  -- because FirstNameMI will just be first name.

		UPDATE @PI_Names
		SET PI_LF  = LastName + ', ' + FirstInitial

		UPDATE  @PI_Names
		SET PI_LFM = PI_LF + ' ' + MiddleInitial
		WHERE MiddleInitial IS NOT NULL

		UPDATE  @PI_Names
		SET PI_LFM = PI_LF
		WHERE MiddleInitial IS  NULL

		UPDATE @PI_Names
		SET PI_LastNameFirstName = LastName + ', ' + FirstName

		--DECLARE @Table TABLE (Project varchar(50), Accession varchar(50), PI varchar(200), OrgR varchar(4))
		INSERT INTO @Table (Project, Accession, PI)
		exec [dbo].[usp_getProjectsByDept] @OrgR = @OrgR

		UPDATE @Table SET OrgR = @OrgR WHERE OrgR IS NULL

		FETCH NEXT FROM myCursor INTO @OrgR
	END

	CLOSE myCursor
	DEALLOCATE myCursor

	IF @IsDebug = 1
		BEGIN
			SELECT 'PI Names:' TableName
			select OrgR, Employee_Name, EID, PI_LFM PI, PI_LastNameFirstName PI_Last_First  
			from @PI_Names
			ORDER BY Employee_Name

			SELECT 'PI Matches:' TableName
			select 
				t1.OrgR,
				Accession, 
				UPPER(REPLACE (PI, '.', '')) PI, 
				CASE WHEN a.EID IS NULL THEN 
						CASE WHEN b.EID IS NULL THEN c.EID
						ELSE b.EID END
					ELSE a.EID 
				END EID, 
				CASE WHEN a.PI_LFM IS NULL THEN  
						CASE WHEN b.PI_LF IS NULL THEN c.PI_LastNameFirstName
						ELSE b.PI_LF END 
					ELSE a.PI_LFM 
				END PI_Match
			from @Table t1
			LEFT OUTER JOIN @PI_Names a ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')   = REPLACE(RTRIM(a.PI_LFM), '  ', ' ')
			LEFT OUTER JOIN @PI_Names b ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')  = REPLACE(RTRIM(b.PI_LF), '  ', ' ')
			LEFT OUTER JOIN @PI_Names c ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')  = REPLACE(RTRIM(c.PI_LastNameFirstName), '  ', ' ')
			WHERE CASE WHEN a.PI_LFM IS NULL THEN 
						CASE WHEN b.PI_LF IS NULL THEN c.PI_LastNameFirstName
						ELSE b.PI_LF END
					ELSE a.PI_LFM 
				END IS NOT NULL
			group by  REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ') ,  PI, b.PI_LF, b.PI_LFM, a.PI_LFM, a.PI_LF, c.PI_LastNameFirstName, accession, c.EID, b.EID, a.EID, t1.OrgR
			order by PI, Accession, t1.OrgR, EID, PI_Match

			SELECT 'Non-Matched PIs:' TableName
			select 
				t1.OrgR,
				Accession, 
				UPPER(REPLACE (PI, '.', '')) PI, 
				CASE WHEN a.EID IS NULL THEN 
						CASE WHEN b.EID IS NULL THEN c.EID
						ELSE b.EID END
					ELSE a.EID 
				END EID, 
				CASE WHEN a.PI_LFM IS NULL THEN  
						CASE WHEN b.PI_LF IS NULL THEN c.PI_LastNameFirstName
						ELSE b.PI_LF END 
					ELSE a.PI_LFM 
				END PI_Match
			from @Table t1
			LEFT OUTER JOIN @PI_Names a ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')   = REPLACE(RTRIM(a.PI_LFM), '  ', ' ')
			LEFT OUTER JOIN @PI_Names b ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')  = REPLACE(RTRIM(b.PI_LF), '  ', ' ')
			LEFT OUTER JOIN @PI_Names c ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ') = REPLACE(RTRIM(c.PI_LastNameFirstName), '  ', ' ')
			WHERE CASE WHEN a.PI_LFM IS NULL THEN 
						CASE WHEN b.PI_LF IS NULL THEN c.PI_LastNameFirstName
						ELSE b.PI_LF END
					ELSE a.PI_LFM 
				END IS NULL
			group by  REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ') ,  PI, b.PI_LF, b.PI_LFM, a.PI_LFM, a.PI_LF, c.PI_LastNameFirstName, accession, c.EID, b.EID, a.EID, t1.OrgR
			order by PI, Accession, t1.OrgR, EID, PI_Match
		END
	ELSE
		BEGIN
			TRUNCATE TABLE [DBO].[PI_Names]
			--TRUNCATE TABLE [DBO].[PI_NumProjects] -- No longer used.
			TRUNCATE TABLE [DBO].PI_Match

			INSERT INTO [DBO].[PI_Names]
			select OrgR, Employee_Name, EID, PI_LFM PI, LastName + ', ' + FirstName PI_Last_First 
			from @PI_Names
			ORDER BY Employee_Name

			-- No longer used:
			--INSERT INTO [DBO].[PI_NumProjects] (NumProjects, PI, OrgR)
			--select count(*) num_projects, UPPER(REPLACE (PI, '.', '')) PI, t1.OrgR 
			--from @Table t1
			--INNER JOIN @PI_Names ON  UPPER(REPLACE (PI, '.', ''))  = PI_LFM
			--group by  UPPER(REPLACE (PI, '.', '')) , t1.OrgR
			--Order BY t1.OrgR, PI

			INSERT INTO [DBO].[PI_Match] (Accession, PI, EID, PI_Match, OrgR )
			select 
				Accession, 
				UPPER(REPLACE (PI, '.', '')) PI, 
				CASE WHEN a.EID IS NULL THEN 
						CASE WHEN b.EID IS NULL THEN c.EID
						ELSE b.EID END
					ELSE a.EID 
				END EID, 
				CASE WHEN a.PI_LFM IS NULL THEN  
						CASE WHEN b.PI_LF IS NULL THEN c.PI_LastNameFirstName
						ELSE b.PI_LF END 
					ELSE a.PI_LFM 
				END PI_Match,
				t1.OrgR 
			from @Table t1
			LEFT OUTER JOIN @PI_Names a ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')   = REPLACE(RTRIM(a.PI_LFM), '  ', ' ')
			LEFT OUTER JOIN @PI_Names b ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')  = REPLACE(RTRIM(b.PI_LF), '  ', ' ')
			LEFT OUTER JOIN @PI_Names c ON REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ')  = REPLACE(RTRIM(c.PI_LastNameFirstName), '  ', ' ')
			group by  REPLACE(RTRIM(UPPER(REPLACE (PI, '.', ''))), '  ', ' ') ,  PI, b.PI_LF, b.PI_LFM, a.PI_LFM, a.PI_LF, c.PI_LastNameFirstName, accession, c.EID, b.EID, a.EID, t1.OrgR
			order by t1.OrgR, PI, Accession, EID, PI_Match

			SELECT 'Non-Matched PIs:' TableName 
			SELECT OrgR, Accession, PI, EID, PI_Match FROM [DBO].[PI_Match]
			WHERE PI_Match IS NULL
			order by PI, Accession, OrgR, EID, PI_Match		
		END

	SET NOCOUNT OFF;
END